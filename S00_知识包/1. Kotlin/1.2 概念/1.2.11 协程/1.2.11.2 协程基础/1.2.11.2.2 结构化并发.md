
### 🌟 结构化并发

🧬 协程遵循**结构化并发**的原则，这意味着新的协程只能在特定的 `CoroutineScope` 中启动，该作用域界定了协程的生命周期。

🔍 上面的例子展示了 `runBlocking` 建立了相应的作用域，这就是为什么前面的例子会等待直到 "World!" 在一秒延迟后被打印出来，然后才退出。

🚀 在实际应用中，你会启动大量的协程。结构化并发确保它们不会丢失和泄漏。

🔒 外部作用域在其所有子协程完成之前无法完成。

🛡️ 结构化并发还确保代码中的任何错误都能被正确报告，永远不会丢失。
