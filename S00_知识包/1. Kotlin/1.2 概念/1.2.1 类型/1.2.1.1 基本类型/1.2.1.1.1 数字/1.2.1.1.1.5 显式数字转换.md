### 显式数字转换
#### 由于不同的表示方式，较小类型并不是较大类型的子类型。 如果它们是的话，就会出现下述问题：

```kotlin
// 假想的代码，实际上并不能编译：
val a: Int? = 1 // 一个装箱的 Int (java.lang.Integer)
val b: Long? = a // 隐式转换产生一个装箱的 Long (java.lang.Long)
print(b == a) // 惊！这将输出“false”鉴于 Long 的 equals() 会检测另一个是否也为 Long
```
#### 所以会悄无声息地失去相等性，更别说同一性了。

#### 因此较小的类型<em>不能</em> 隐式转换为较大的类型。 这意味着把 <code>Byte</code> 型值赋给一个 <code>Int</code> 变量必须显式转换：

```kotlin
val b: Byte = 1 // OK, 字面值会静态检测
// val i: Int = b // 错误
val i1: Int = b.toInt()
```

#### 所有数字类型都支持转换为其他类型：

- <code>toByte()</code>: <code>Byte</code>
- <code>toShort()</code>: <code>Short</code>
- <code>toInt()</code>: <code>Int</code>
- <code>toLong()</code>: <code>Long</code>
- <code>toFloat()</code>: <code>Float</code>
- <code>toDouble()</code>: <code>Double</code>

#### 很多情况都不需要显式类型转换，因为类型会从上下文推断出来， 而算术运算会有重载做适当转换，例如：

```kotlin
val l = 1L + 3 // Long + Int => Long
```