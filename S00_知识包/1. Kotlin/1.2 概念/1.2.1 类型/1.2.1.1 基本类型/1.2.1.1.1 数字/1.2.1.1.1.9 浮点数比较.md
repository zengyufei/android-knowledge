### 浮点数比较
#### 本节讨论的浮点数操作如下：

- 相等性检测：<code>a == b</code> 与 <code>a != b</code>
- 比较操作符：<code>a < b</code>、 <code>a > b</code>、 <code>a <= b</code>、 <code>a >= b</code>
- 区间实例以及区间检测：<code>a..b</code>、 <code>x in a..b</code>、 <code>x !in a..b</code>
#### 当其中的操作数 <code>a</code> 与 <code>b</code> 都是静态已知的 <code>Float</code> 或 <code>Double</code> 或者它们对应的可空类型（声明为该类型，或者推断为该类型，或者智能类型转换的结果是该类型），两数字所形成的操作或者区间遵循 IEEE 754 浮点运算标准。

#### 然而，为了支持泛型场景并提供全序支持，对于并非静态类型就是浮点数的情况，行为是不同的。例如是 <code>Any</code>、 <code>Comparable<...></code> 或者 <code>Collection<T></code> 类型。 这种情况下，这些操作使用为 <code>Float</code> 与 <code>Double</code> 实现的 <code>equals</code> 与 <code>compareTo</code>。 因此：

- 认为 <code>NaN</code> 与其自身相等
- 认为 <code>NaN</code> 比包括正无穷大（<code>POSITIVE_INFINITY</code>）在内的任何其他元素都大
- 认为 <code>-0.0</code> 小于 <code>0.0</code>
#### 以下示例显示了静态类型作为浮点数 （<code>Double.NaN</code>）的操作数与静态类型<b>并非</b>作为浮点数的操作数（<code>listOf(T)</code>）之间的行为差异。

```kotlin
fun main() {
    //sampleStart
    // 静态类型作为浮点数的操作数
    println(Double.NaN == Double.NaN)                 // false
    // 静态类型并非作为浮点数的操作数
    // 所以 NaN 等于它本身
    println(listOf(Double.NaN) == listOf(Double.NaN)) // true

    // 静态类型作为浮点数的操作数
    println(0.0 == -0.0)                              // true
    // 静态类型并非作为浮点数的操作数
    // 所以 -0.0 小于 0.0
    println(listOf(0.0) == listOf(-0.0))              // false

    println(listOf(Double.NaN, Double.POSITIVE_INFINITY, 0.0, -0.0).sorted())
    // [-0.0, 0.0, Infinity, NaN]
    //sampleEnd
}
```