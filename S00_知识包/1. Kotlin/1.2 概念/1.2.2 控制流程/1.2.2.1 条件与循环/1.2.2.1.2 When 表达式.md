## 🌟 When 表达式

🔍 `when` 定义了一个具有多个分支的条件表达式。

🔄 它就是 `switch` 语句。

#### 它的简单形式如下所示。

```kotlin
when (变量) {
    1 -> print("变量 == 1")
    2 -> print("变量 == 2")
    else -> {
        print("变量 既不是 1 也不是 2")
    }
}
```
🔍 `when` 将它的参数与所有的分支条件顺序比较，直到某个分支满足条件。

#### 🔀 `when` 既可以作为表达式使用也可以作为语句使用。

🔄 如果它被当做表达式，第一个符合条件的分支的值就是整个表达式的值，如果当做语句使用，则忽略个别分支的值。 

类似于 `if`，每一个分支可以是一个代码块，它的值是块中最后的表达式的值。

### ➡️ 如果其他分支都不满足条件将会求值 `else` 分支。

⚠️ 如果 `when` 作为一个*表达式*使用，那么必须有 `else` 分支，除非编译器能够检测出所有的可能情况都已经覆盖了。

例如，对于 枚举（`enum`）类 条目与 密封（`sealed`）类

```kotlin
enum class 数字枚举 {
    零, 一
}

fun 获取随机数字(): 数字枚举 {
    return 数字枚举.values().random()
}

fun main() {
    val 数值 = when (获取随机数字()) {
        数字枚举.零 -> 0
        数字枚举.一 -> 1
        // 不需要 'else' 分支，因为所有情况都已覆盖
    }

    println(数值)
}
```

密封（`sealed`）类 示例：

```kotlin
sealed class 颜色 {
    object 红 : 颜色()
    object 绿 : 颜色()
    object 蓝 : 颜色()
}

fun 描述颜色(颜色: 颜色): String = when (颜色) {
    is 颜色.红 -> "这是红色"
    is 颜色.绿 -> "这是绿色"
    is 颜色.蓝 -> "这是蓝色"
    // 不需要 else 分支，因为所有可能的情况都已覆盖
}

fun main() {
    val 红色 = 颜色.红
    val 绿色 = 颜色.绿
    val 蓝色 = 颜色.蓝

    println(描述颜色(红色))
    println(描述颜色(绿色))
    println(描述颜色(蓝色))
}

// 这是红色
// 这是绿色
// 这是蓝色
```

#### 🔍 在 `when` *语句*中，以下情况下 `else` 分支是必需的：
* 🔀 `when` 的主体是 `Boolean`、`enum` 或 `sealed` 类型，或它们的可空对应类型。
* 🧩 `when` 的分支没有覆盖该主体的所有可能情况。

```kotlin
enum class 颜色 {
    红, 绿, 蓝
}

when (获取颜色()) {
    颜色.红 -> println("红色")
    颜色.绿 -> println("绿色")
    颜色.蓝 -> println("蓝色")
    // 不需要 'else' 分支，因为所有情况都已覆盖
}

when (获取颜色()) {
    颜色.红 -> println("红色") // 没有 绿 和 蓝 的分支
    else -> println("不是红色") // 需要 'else' 分支
}
```


#### 🔗 要为多个情况定义共同的行为，可以在一行中用逗号组合它们的条件：

```kotlin
fun 测试(任意值: Any) {
    when (任意值) {
        0, 1 -> println("任意值 == 0 或 任意值 == 1")
        else -> println("其他情况")
    }
}

fun main() {
    测试(0)
    测试(1)
    测试("a")
    测试(9)
}

// 任意值 == 0 或 任意值 == 1
// 任意值 == 0 或 任意值 == 1
// 其他情况
// 其他情况
```

#### 🔀 可以用任意表达式（而不只是常量）作为分支条件

```kotlin
when (某值) {
    某字符串.toInt() -> print("某字符串编码了某值")
    else -> print("某字符串没有编码某值")
}
```

#### 🔍 还可以检测一个值在（`in`）或者不在（`!in`）一个 `区间` 或者集合中：

```kotlin
fun 测试When(数字: Int) {
    val 有效数字列表 = listOf(42, 73, 100)
    print("当 数字 = $数字 时：")
    when (数字) {
        in 1..10 -> println("数字在范围内")
        in 有效数字列表 -> println("数字是有效的")
        !in 10..20 -> println("数字在范围外")
        else -> println("以上都不是")
    }
}
fun main() {
    测试When(5)
    测试When(42)
    测试When(15)
    测试When(25)
}

// 当 数字 = 5 时：数字在范围内
// 当 数字 = 42 时：数字是有效的
// 当 数字 = 15 时：以上都不是
// 当 数字 = 25 时：数字在范围外
```

#### 🔍 另一种选择是检测一个值是（`is`）或者不是（`!is`）一个特定类型的值。

> 注意：
>由于 `智能转换`，你可以访问该类型的方法与属性而无需任何额外的检测。

```kotlin
fun 有前缀(任意值: Any) = when(任意值) {
    is String -> 任意值.startsWith("prefix")
    else -> false
}
```

#### 🔀 `when` 也可以用来取代 `if`-`else` `if` 链。

如果不提供参数，所有的分支条件都是简单的布尔表达式，而当一个分支的条件为真时则执行该分支：

```kotlin
when {
    x.是奇数() -> print("x是奇数")
    y.是偶数() -> print("y是偶数")
    else -> print("x+y是奇数")
}
```

#### 🔍 可以使用以下语法将 *when* 的主语（subject，译注：指 `when` 所判断的表达式）捕获到变量中：

```kotlin
fun 请求.获取主体() =
    when (val 响应 = 执行请求()) {
        is 成功 -> 响应.主体
        is 网络错误 -> throw 网络异常(响应.状态)
    }
```

> 🔍 在 *when* 主语中引入的变量的作用域仅限于 *when* 主体。