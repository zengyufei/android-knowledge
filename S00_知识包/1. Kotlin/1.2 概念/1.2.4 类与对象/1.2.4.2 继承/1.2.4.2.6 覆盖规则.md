## 🔄 覆盖规则

🌳 在 Kotlin 中，实现继承由下述规则规定：如果一个类从它的直接超类继承相同成员的多个实现，它必须覆盖这个成员并提供其自己的实现（也许用继承来的其中之一）。

#### 🔗 如需表示采用从哪个超类型继承的实现，请使用由尖括号中超类型名限定的 `super`，如 `super<Base>`：

```kotlin
open class 矩形 {
    open fun 绘制() { /* …… */ }
}

interface 多边形 {
    fun 绘制() { /* …… */ } // 接口成员默认就是"open"的
}

class 正方形() : 矩形(), 多边形 {
    // 编译器要求覆盖 绘制()：
    override fun 绘制() {
        super<矩形>.绘制() // 调用 矩形.绘制()
        super<多边形>.绘制() // 调用 多边形.绘制()
    }
}
```

🔀 可以同时继承 `矩形` 与 `多边形`，

🎨 但是二者都有各自的 `绘制()` 实现，所以必须在 `正方形` 中覆盖 `绘制()`，

🔍 并为其提供一个单独的实现以消除歧义。