# 🔒 密封类与密封接口

🛡️ 密封（Sealed）类和接口提供了对类层次结构的受控继承。

🕰️ 密封类的所有直接子类在编译时就已知。除了定义密封类的模块和包之外，不能出现其他子类。

🔄 同样的逻辑也适用于密封接口及其实现：一旦包含密封接口的模块被编译，就不能创建新的实现。

> 🔗 直接子类是直接继承自其超类的类。
>
> 🌳 间接子类是从其超类多于一个层级继承的类。

🔍 当你将密封类和接口与 `when` 表达式结合使用时，你可以涵盖所有可能子类的行为，并确保不会创建新的子类来对你的代码产生不利影响。

🌟 密封类最适用于以下场景：

* 🔒 **需要限制类继承：** 你有一个预定义的、有限的子类集合来扩展一个类，所有这些子类在编译时都是已知的。
* 🛡️ **需要类型安全设计：** 安全性和模式匹配对你的项目至关重要。特别是对于状态管理或处理复杂的条件逻辑。例如，请查看 ``Use sealed classes with when expressions``。
* 🔐 **使用封闭的API：** 你希望为库提供健壮和可维护的公共API，确保第三方客户端按预期使用API。


> 🆕 Java 15 引入了一个类似的概念，其中密封类使用 `sealed` 关键字和 `permits` 子句来定义受限制的层次结构。
