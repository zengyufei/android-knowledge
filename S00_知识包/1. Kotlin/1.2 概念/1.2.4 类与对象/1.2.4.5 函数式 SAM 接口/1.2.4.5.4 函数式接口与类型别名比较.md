## 🔄 函数式接口与类型别名比较

🌟 你也可以简单地使用 `类型别名` 来重写上面的函数式类型：

```kotlin
typealias IntPredicate = (i: Int) -> Boolean

val isEven: IntPredicate = { it % 2 == 0 }

fun main() {
   println("Is 7 even? - ${isEven(7)}")
}
```

🔍 然而，函数式接口和`类型别名`用途并不相同。

🏷️ 类型别名只是现有类型的名称——它们不会创建新的类型，而函数式接口却会创建新类型。

🔧 你可以为特定的函数式接口提供扩展，这些扩展对普通函数或它们的类型别名是不适用的。

🧩 类型别名只能有一个成员，而函数式接口可以有多个非抽象成员以及一个抽象成员。

🔗 函数式接口还可以实现以及继承其他接口。

🌟 函数式接口比类型别名更灵活并且提供了更多的功能，但它们在语法上和运行时可能更昂贵，因为它们可能需要转换为特定的接口。

🤔 当你选择在代码中使用哪一个时，请考虑你的需求：
* 🎯 如果你的API需要接受一个具有特定参数和返回类型的函数（任何函数）——使用简单的函数类型或定义一个类型别名来为相应的函数类型提供更短的名称。
* 🏗️ 如果你的API接受比函数更复杂的实体——例如，它有无法在函数类型签名中表达的非平凡契约和/或操作——为它声明一个单独的函数式接口。