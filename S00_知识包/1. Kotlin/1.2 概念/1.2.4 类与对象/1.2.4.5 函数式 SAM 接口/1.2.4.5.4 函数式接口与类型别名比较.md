## 🔄 函数式接口与类型别名比较

#### 🌟 你也可以简单地使用 `类型别名` 来重写上面的函数式类型：

```kotlin
typealias 打印机 = () -> Unit

fun 使用打印机(外部调用: 打印机): 打印机 {
    return 外部调用
}

fun main() {
    // 可定义类型为 打印机函数 类型
    val 打印: 打印机 = { println("Hello, Kotlin!") }
    打印()

    val 另一个打印机 = ::使用打印机
    另一个打印机 { println("函数引用创建的Printer") }()
}

// Hello, Kotlin!
// 函数引用创建的Printer
```


#### 🔍 然而，函数式接口和`类型别名`用途并不相同。

🏷️ `类型别名` 只是现有类型的名称——它们不会创建新的类型，而 `函数式接口` 却会创建新类型。

🔧 你可以为特定的 `函数式接口` 提供扩展，这些扩展对普通函数或它们的 `类型别名` 是不适用的。

🧩 `类型别名` 只能有一个成员，而 `函数式接口` 可以有多个非抽象成员以及一个抽象成员。

#### 🔗 `函数式接口` 还可以实现以及继承其他接口。

🌟 `函数式接口` 比 `类型别名` 更灵活并且提供了更多的功能，但它们在语法上和运行时可能更昂贵，因为它们可能需要转换为特定的接口。

#### 🤔 当你选择在代码中使用哪一个时，请考虑你的需求：

* 🎯 如果你的 API 需要接受一个具有特定参数和返回类型的函数（任何函数）——使用简单的函数类型或定义一个 `类型别名` 来为相应的函数类型提供更短的名称。

* 🏗️ 如果你的 API 接受比函数更复杂的实体——例如，它有无法在函数类型签名中表达的非平凡契约和/或操作——为它声明一个单独的 `函数式接口`。