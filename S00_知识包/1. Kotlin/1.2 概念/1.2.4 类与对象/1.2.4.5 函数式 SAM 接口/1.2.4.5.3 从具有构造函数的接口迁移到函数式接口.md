## 🔄 从具有构造函数的接口迁移到函数式接口

🚀 从1.6.20版本开始，Kotlin支持函数式接口构造函数的`可调用引用`，这为从具有构造函数的接口迁移到函数式接口提供了一种源代码兼容的方式。

#### 🤔 考虑以下代码：

```kotlin
interface 打印机 {
    fun 打印()
}

fun 使用打印机(外部调用: () -> Unit): 打印机 = object : 打印机 { override fun 打印() = 外部调用() }

fun main() {
    val 我的打印机 = 使用打印机 { println("Hello, Kotlin!") }

    我的打印机.打印()

    val 另一个打印机 = ::使用打印机
    另一个打印机 { println("函数引用创建的Printer") }.打印()
}

// Hello, Kotlin!
// 函数引用创建的Printer
```

#### 🔍 代码解释：

* ##### 高阶函数：

  * `fun 使用打印机(外部调用: () -> Unit): 打印机` 是一个高阶函数，它接受一个函数作为参数。

  * 这个参数 `外部调用` 是一个无参数、返回 Unit（即没有返回值）的函数类型。

  * `使用打印机` 函数的返回类型是 `打印机`，表示这个函数会返回一个实现了 `打印机` 接口的对象。

* ##### 匿名类：

  * `object : 打印机 { ... }` 创建了一个匿名类，这个类实现了 `打印机` 接口。

  * 由于 `打印机` 接口有一个方法 `打印()`，所以你需要 `重写` 这个方法。

* ##### 重写方法：

  * `override fun 打印() = 外部调用()` 是对 `打印()` 方法的实现。这个实现调用了传入的 `外部调用` 函数。

  * 当你调用 `打印()` 方法时，它会执行 `外部调用` 中的代码。

* ##### 函数引用：

  * `::使用打印机` 是一个函数引用，表示引用 `使用打印机` 函数。

#### 🔄 启用函数式接口构造函数的可调用引用后，这段代码可以被简化为一个函数式接口声明：

```kotlin
fun interface 打印机 {
    fun 打印()
}

fun 使用打印机(外部调用: () -> Unit): 打印机 {
    return 打印机 { 外部调用() }
}

fun main() {
    val 我的打印机 = 使用打印机 { println("Hello, Kotlin!") }

    我的打印机.打印()

    val 另一个打印机 = ::使用打印机
    另一个打印机 { println("函数引用创建的Printer") }.打印()
}

// Hello, Kotlin!
// 函数引用创建的Printer
```

#### 🏗️ 它的构造函数将被隐式创建，任何使用 `::使用打印机` 函数引用的代码都将编译通过。例如：

```kotlin
fun interface 打印机 {
    fun 打印()
}

fun 执行打印(打印机: 打印机) {
    打印机.打印()
}

fun main() {
    执行打印( ::打印机  { println("另一个打印机") } )
}

// 另一个打印机
```

#### 🔒 通过使用 `@Deprecated` 注解和 `DeprecationLevel.HIDDEN` 来标记旧的 `打印机` 函数，以保持二进制兼容性：

```kotlin
@Deprecated(message = "关于废弃的消息", level = DeprecationLevel.HIDDEN)
fun 打印机(...) {...}
```