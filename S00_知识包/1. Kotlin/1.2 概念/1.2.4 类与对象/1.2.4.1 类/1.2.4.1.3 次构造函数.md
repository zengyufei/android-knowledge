### 🏗️ 次构造函数

<b>主构造函数：</b>在类声明中定义，简洁，通常用于初始化属性。

<b>次构造函数：</b>使用 constructor 关键字定义代码块，可以有多个，适用于需要不同初始化方式的场景。

#### 🔧 类也可以声明前缀有 `constructor` 的*次构造函数*：


```kotlin
class Person() {
    constructor() {
        println("次构造函数)
    }
}

fun main() {
    val 小明 = Person()
}

// 输出：次构造函数
```


#### 🔀 委托（调用）到同一个类的另一个构造函数用 `this` 关键字即可：

```kotlin
class Person(val 姓名: String) {

    val 孩子们: MutableList<Person> = mutableListOf()

    constructor(姓名: String, 父母: Person) : this(姓名) {
        父母.孩子们.add(this)
    }
}

fun main() {
    val 小明的爸爸 = Person("小明的爸爸")
    val 小明 = Person("小明", 小明的爸爸)
    val 小红 = Person("小红", 小明的爸爸)

    println("小明的爸爸有 ${小明的爸爸.孩子们.size} 个小孩")
}

// 小明的爸爸有 2 个小孩
```

> 🔬 请注意，初始化块中的代码实际上会成为主构造函数的一部分。

🔁 对主构造函数的委托发生在访问次构造函数的第一条语句时，因此所有初始化块与属性初始化器中的代码都会在次构造函数体之前执行。

#### 🔄 即使该类没有主构造函数，这种委托仍会隐式发生，并且仍会执行初始化块：

```kotlin
class Person(val 姓名: String) {
    val 第一个属性 = "第一个属性: $姓名".also(::println)

    init {
        println("第一个初始化块: 姓名是 $姓名")
    }

    val 第二个属性 = "第二个属性: ${姓名.length}".also(::println)

    init {
        println("第二个初始化块: 姓名是 $姓名")
    }

    // 次构造函数
    constructor(姓名: String, 年龄: Int) : this(姓名) {
        println("次构造函数: 姓名是 $姓名, 年龄是 $年龄")
    }
}

fun main() {
    val person = Person("Alice", 30)
}

// 第一个属性: Alice
// 第一个初始化块: 姓名是 Alice
// 第二个属性: 5
// 第二个初始化块: 姓名是 Alice
// 次构造函数: 姓名是 Alice, 年龄是 30
```

🏗️ 如果一个非抽象类没有声明任何（主或次）构造函数，它会有一个生成的不带参数的主构造函数。构造函数的可见性是 public。

> 大白话：所有次构造函数最终必须调用主构造函数，对主构造函数参数赋值，然后按摆放顺序执行成员变量或初始化块，最后执行次构造函数代码。

#### 🔒 如果你不希望你的类有一个公有构造函数，那么声明一个带有非默认可见性的空的主构造函数：

```kotlin
class Person private constructor() { /*……*/ }
```

> 🔧 在 JVM 上，如果主构造函数的所有参数都有默认值，编译器会生成一个额外的无参构造函数，它将使用默认值。这使得 Kotlin 更易于使用像 `Jackson` 或者 `JPA` 这样的通过无参构造函数创建类实例的库。
>
> ```kotlin
> class Person(val 姓名: String = "")
> ```

