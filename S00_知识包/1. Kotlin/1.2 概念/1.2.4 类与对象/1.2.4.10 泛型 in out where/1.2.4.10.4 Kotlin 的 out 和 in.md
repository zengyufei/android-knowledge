### 🌟 Kotlin 的 out 和 in

和 Java 泛型一样，Kolin 中的泛型本身也是不可变的。

#### 不过换了一种表现形式：

- 使用关键字 out 来支持协变，等同于 Java 中的上界通配符 ? extends。
- 使用关键字 in 来支持逆变，等同于 Java 中的下界通配符 ? super。

```kotlin
// kotlin
val appleShop: Shop<out Fruit>
val fruitShop: Shop<in Apple>
```

它们完全等价于：

```java
// Java
Shop<? extends Fruit> appleShop;
Shop<? super Apple> fruitShop;
```

换了个写法，但作用是完全一样的。out 表示，我这个变量或者参数只用来输出，不用来输入，你只能读我不能写我；in 就反过来，表示它只用来输入，不用来输出，你只能写我不能读我。

#### 想象你有一个水果篮：

- 水果篮 (可以装任何类型的水果)
  - 水果
    - 苹果
    - 香蕉


#### 🤔 假设有一个泛型接口 `水果篮<T>`，该接口中不存在任何以 `T` 作为参数的方法，只是方法返回 `T` 类型值：

```java
// Java
interface 水果篮<T> {
    T 什么水果();
}
```
🔒 这个接口中没有任何以 `T` 作为参数的方法，只是返回 `T` 类型的值。

🤔 在 `水果篮<水果>` 类型的变量中存储 `水果篮<苹果>` 实例的引用是安全的，因为没有方法可以直接操作 `T`。
 
 ####  🚫 然而，Java 编译器并不知道这一点，因此会禁止这样的操作：

```java
// Java
void 猜猜是什么水果(水果篮<苹果> 篮子) {
    水果篮<水果> 水果篮 = 篮子; // ！！！在 Java 中不允许
    // ……
}
```

```java
// Java
class 水果 {}

class 苹果 extends 水果{}

interface 水果篮<T> {
    T 什么水果();
}

class 苹果专用水果篮 implements 水果篮<苹果> {
    public  苹果 什么水果() {
        return new 苹果();
    }
}

void 猜猜是什么水果(水果篮<水果> 篮子) {
    水果篮<水果> 水果篮 = 篮子; // ！！！在 Java 中不允许
    // ……
}

... 
苹果专用水果篮 苹果篮子 = new 苹果专用水果篮();
猜猜是什么水果(苹果篮子); // 这种情况会编译错误

// 在没有使用通配符的情况下，即使 苹果 是 水果 的子类，但是它们还是两个完全不同的类型
// 所以 水果篮<水果> 与 水果篮<苹果> 并不能赋值。
```

🔧 为了修正这一点，我们可以使用 Java 中的泛型通配符，将对象的类型声明为 `水果篮<? extends 水果>`。这样可以安全地使用 `篮子`：

```java
// Java
static void 猜猜是什么水果(水果篮<? extends 水果> 篮子) {
    // 水果篮<水果> 水果篮 = 篮子; // 但还是不能直接赋值给 水果篮<水果>

    // 现在可以安全地使用 篮子
    水果 究竟是什么水果 = 篮子.什么水果();
    System.out.println(究竟是什么水果.getClass().getSimpleName());
}
```

🤖 虽然我们仍然可以在该对象上调用相同的方法，但使用通配符的方式让编译器能够理解我们在处理的是一个可能的子类型。这种方式确保了类型安全，避免了潜在的类型错误。。

#### 🌟 在 Kotlin 中，有一种方法向编译器解释这种情况。这称为 *协变*：

#### `水果篮` 是一个泛型接口， 能装任何水果

```kotlin
interface 水果篮<out T> {
    fun 什么水果(): T
}
```

#### 你实现了一个专门 `装苹果的水果篮`

```kotlin
class 苹果专用水果篮 : 水果篮<苹果> {
    override fun 什么水果(): 苹果 {
        return 苹果()
    }
}
```

#### 你可以把这个篮子看作是一个 `装水果的水果篮`

```kotlin
fun 猜猜是什么水果(篮子: 水果篮<水果>) {

    val 装水果的水果篮: 水果篮<水果> = 篮子

    val 究竟是什么水果: 水果 = 装水果的水果篮.什么水果()
    println("一种水果: ${究竟是什么水果::class.simpleName}")

    // 方法从定义到方法体内部没有使用任何具体子类类型
    // 全都协变成父类类型： 水果
}

// 一种水果: 苹果
```

#### 所有的苹果都是水果，所以一个装苹果的篮子也可以被视为装水果的篮子。

- `协变（out）` 来定义 `水果篮<out T>`，这意味着 T 只能用于输出，而不用于输入

- 因为 `苹果` 是 `水果` 的子类

- 使得 `水果篮<苹果>` 可以被视为 `水果篮<水果>` 的子类型


#### 🔑 使用 `out` 声明的类型参数规则：

1. 只能用于输出位置
2. 允许子类型关系：`水果篮<苹果>` 可作为 `水果篮<水果>` 的子类型

#### 💡 关键概念：

- 协变：类型参数 `T` 被声明为 `out`
- 生产者：`水果篮<T>` 产生 `T`，不消费 `T`
- 声明处型变：在类型参数声明时使用 `out` 注解

🔄 这与 Java 的*使用处型变*相反，其类型用途通配符使得类型协变。

#### 🎭 另外除了 `out`，Kotlin 又补充了一个型变注解：`in`。

它使得一个类型参数 *逆变*，即只可以消费而不可以生产。

逆变类型的一个很好的例子是 `Comparable`：

```kotlin
fun interface Comparable<in T> {
    operator fun compareTo(other: T): Int
}

fun demo(x: Comparable<Number>) {
    // 1.0 拥有类型 Double，它是 Number 的子类型
    val result1 = x.compareTo(3.42)
    println(result1)
    
    // h还可以将 x 赋给类型为 Comparable <Float> 的变量
    val y: Comparable<Float> = x
    val result2 = y.compareTo(4.52f)
    println(result2)
}

fun main() {
    val test: Comparable<Number> = Comparable { other ->
        when {
            (other is Double && other > 3) -> 10
            (other is Double && other > 4) -> 1
            (other is Float && other > 3) -> 55
            (other is Float && other > 4) -> 23
            else -> 20
        }
    }
    
    demo(test)
}

// 10
// 55
```

🔤 `in` 和 `out` 这两个词看起来是自解释的（因为它们已经在 C# 中成功使用很长时间了）。

🧠 因此上面提到的助记符不是真正需要的。可以将其改写为更高级的抽象：

> 🌟 **`存在性` 变换：消费者 in, 生产者 out！** 😊
