### 🌟 声明处型变

##### 声明处型变是指在定义泛型类型时，指定该泛型类型是 `协变` 还是 `逆变`。

 - **协变**：允许用子类型替代父类型，适用于返回类型，使用 `out`。

 - **逆变**：允许用父类型替代子类型，适用于输入类型，使用 `in`。


#### 🤔 假设有一个泛型接口 `Source<T>`，该接口中不存在任何以 `T` 作为参数的方法，只是方法返回 `T` 类型值：

```java
// Java
interface Source<T> {
    T nextT();
}
```

🔒 那么，在 `Source <Object>` 类型的变量中存储 `Source <String>` 实例的引用是极为安全的

#### 🚫 没有消费者-方法可以调用。但是 Java 并不知道这一点，并且仍然禁止这样操作：

```java
// Java
void demo(Source<String> strs) {
  Source<Object> objects = strs; // ！！！在 Java 中不允许
  // ……
}
```

🔧 为了修正这一点，我们必须声明对象的类型为 `Source<? extends Object>`。

🤔 这么做毫无意义，因为我们可以像以前一样在该对象上调用所有相同的方法，所以更复杂的类型并没有带来价值。

🤖 但编译器并不知道。

#### 🌟 在 Kotlin 中，有一种方法向编译器解释这种情况。这称为 *声明处型变*：

#### 想象你有一个水果篮：

- 水果篮 (可以装任何类型的水果)
  - 水果
    - 苹果
    - 香蕉

#### `水果篮` 是一个泛型接口， 能装任何水果

```kotlin
interface 水果篮<out T> {
    fun 什么水果(): T
}
```

#### 你实现了一个专门 `装苹果的水果篮`

```kotlin
class 苹果专用水果篮 : 水果篮<苹果> {
    override fun 什么水果(): 苹果 {
        return 苹果()
    }
}
```

#### 你可以把这个篮子看作是一个 `装水果的水果篮`

```kotlin
fun 猜猜是什么水果(篮子: 水果篮<苹果>) {

    val 装水果的水果篮: 水果篮<水果> = 篮子

    val 究竟是什么水果: 水果 = 装水果的水果篮.什么水果()
    println("一种水果: ${究竟是什么水果::class.simpleName}")

    // 方法内部没有使用任何子类类型
    // 全都协变成父类类型： 水果
}

// 一种水果: 苹果
```

#### 所有的苹果都是水果，所以一个装苹果的篮子也可以被视为装水果的篮子。

- `协变（out）` 来定义 `水果篮<out T>`，这意味着 T 只能用于输出，而不用于输入

- 因为 `苹果` 是 `水果` 的子类

- 使得 `水果篮<苹果>` 可以被视为 `水果篮<水果>` 的子类型


#### 🔑 使用 `out` 声明的类型参数规则：

1. 只能用于输出位置
2. 允许子类型关系：`水果篮<苹果>` 可作为 `水果篮<水果>` 的子类型

#### 💡 关键概念：

- 协变：类型参数 `T` 被声明为 `out`
- 生产者：`水果篮<T>` 产生 `T`，不消费 `T`
- 声明处型变：在类型参数声明时使用 `out` 注解

🔄 这与 Java 的*使用处型变*相反，其类型用途通配符使得类型协变。

#### 🎭 另外除了 `out`，Kotlin 又补充了一个型变注解：`in`。

它使得一个类型参数 *逆变*，即只可以消费而不可以生产。

逆变类型的一个很好的例子是 `Comparable`：

```kotlin
fun interface Comparable<in T> {
    operator fun compareTo(other: T): Int
}

fun demo(x: Comparable<Number>) {
    // 1.0 拥有类型 Double，它是 Number 的子类型
    val result1 = x.compareTo(3.42)
    println(result1)
    
    // h还可以将 x 赋给类型为 Comparable <Float> 的变量
    val y: Comparable<Float> = x
    val result2 = y.compareTo(4.52f)
    println(result2)
}

fun main() {
    val test: Comparable<Number> = Comparable { other ->
        when {
            (other is Double && other > 3) -> 10
            (other is Double && other > 4) -> 1
            (other is Float && other > 3) -> 55
            (other is Float && other > 4) -> 23
            else -> 20
        }
    }
    
    demo(test)
}

// 10
// 55
```

🔤 `in` 和 `out` 这两个词看起来是自解释的（因为它们已经在 C# 中成功使用很长时间了）。

🧠 因此上面提到的助记符不是真正需要的。可以将其改写为更高级的抽象：

> 🌟 **`存在性` 变换：消费者 in, 生产者 out！** 😊
