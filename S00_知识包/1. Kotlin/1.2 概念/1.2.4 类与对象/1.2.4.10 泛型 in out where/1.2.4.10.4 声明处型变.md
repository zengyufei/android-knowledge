### 🌟 声明处型变

**协变**：允许用子类型替代父类型，适用于返回类型，使用 `out`。

**逆变**：允许用父类型替代子类型，适用于输入类型，使用 `in`。

**不变**：默认情况下，泛型类型是不可变的。即 List\<T\> 和 List\<U\> 被视为不同的类型，即使 T 是 U 的子类型。

#### 🤔 假设有一个泛型接口 `Source<T>`，该接口中不存在任何以 `T` 作为参数的方法，只是方法返回 `T` 类型值：

```java
// Java
interface Source<T> {
    T nextT();
}
```

🔒 那么，在 `Source <Object>` 类型的变量中存储 `Source <String>` 实例的引用是极为安全的

#### 🚫 没有消费者-方法可以调用。但是 Java 并不知道这一点，并且仍然禁止这样操作：

```java
// Java
void demo(Source<String> strs) {
  Source<Object> objects = strs; // ！！！在 Java 中不允许
  // ……
}
```

🔧 为了修正这一点，我们必须声明对象的类型为 `Source<? extends Object>`。

🤔 这么做毫无意义，因为我们可以像以前一样在该对象上调用所有相同的方法，所以更复杂的类型并没有带来价值。

🤖 但编译器并不知道。

#### 🌟 在 Kotlin 中，有一种方法向编译器解释这种情况。这称为 *声明处型变*：

🏷️ 可以标注 `Source` 的*类型参数* `T` 作用于输出，而不用于输入。

#### 🔑 为此请使用 `out` 修饰符：

```kotlin
interface Source<out T> {
    fun nextT(): T
}

fun demo(strs: Source<String>) {
     // 协变（out）来定义 Source<out T>，这意味着 T 只能用于输出，而不用于输入
     // 因为 String 是 Any 的子类
     // 使得 Source<String> 可以被视为 Source<Any> 的子类型
    val objects: Source<Any> = strs
    // ……
}
```

🔑 使用 `out` 声明的类型参数规则：

1. 只能用于输出位置
2. 允许子类型关系：`Source<子类>` 可作为 `Source<父类>` 的子类型

💡 关键概念：
- 协变：类型参数 `T` 被声明为 `out`
- 生产者：`Source<T>` 产生 `T`，不消费 `T`
- 声明处型变：在类型参数声明时使用 `out` 注解

🔄 这与 Java 的*使用处型变*相反，其类型用途通配符使得类型协变。

#### 🎭 另外除了 `out`，Kotlin 又补充了一个型变注解：`in`。

它使得一个类型参数 *逆变*，即只可以消费而不可以生产。逆变类型的一个很好的例子是 `Comparable`：

```kotlin
fun interface Comparable<in T> {
    operator fun compareTo(other: T): Int
}

fun demo(x: Comparable<Number>) {
    // 1.0 拥有类型 Double，它是 Number 的子类型
    val result1 = x.compareTo(3.42)
    println(result1)
    
    // h还可以将 x 赋给类型为 Comparable <Float> 的变量
    val y: Comparable<Float> = x
    val result2 = y.compareTo(4.52f)
    println(result2)
}

fun main() {
    val test: Comparable<Number> = Comparable { other ->
        when {
            (other is Double && other > 3) -> 10
            (other is Double && other > 4) -> 1
            (other is Float && other > 3) -> 55
            (other is Float && other > 4) -> 23
            else -> 20
        }
    }
    
    demo(test)
}

// 10
// 55
```

🔤 `in` 和 `out` 这两个词看起来是自解释的（因为它们已经在 C# 中成功使用很长时间了）。

🧠 因此上面提到的助记符不是真正需要的。可以将其改写为更高级的抽象：

> 🌟 **`存在性` 变换：消费者 in, 生产者 out！** 😊
