### 🌟 Java 中的泛型与通配符

### 🔝 泛型的上界通配符

##### 🔒 因为 Java 的泛型本身具有「不可变性 Invariance」。

* 🍎 所以即使 `水果` 类是 `苹果` 类的父类。

* 📋 但 Java 里面认为 `List<水果>` 和 `List<苹果>` 类型并不一致。

* 🧬 也就是说，子类的泛型 `List<苹果>` 不属于泛型 `List<水果>` 的子类。

#### 🚫 所以这样的代码并不被运行:

```java
List<苹果> 苹果列表 = new ArrayList<苹果>();
List<水果> 水果列表 = 苹果列表;
// 👆 多态用在这里会报错 Required type:List<水果> Provided: List<苹果>
```

🤔 那假如我们想突破这层限制，该怎么办呢？

#### 🔓 使用上界通配符 `? extends`：

```java
List<苹果> 苹果列表 = new ArrayList<苹果>();
List<? extends 水果> 水果列表 = 苹果列表;
// 👆使用上界通配符后，编译不再报错
```

🔝 「上界通配符」，可以使 Java 泛型具有「协变性」，协变就是允许上面的赋值是合法的。

> 🌳 在继承关系树中，子类继承自父类，可以认为父类在上，子类在下。`extends` 限制了泛型类型的父类型，所以叫上界。

##### 🤔 它有两层含义：

* 🔍 其中 `?` 是个通配符，表示这个 `List` 的泛型类型是一个未知类型。

* 🚧 `extends` 限制了这个未知类型的上界，也就是泛型类型必须满足这个 `extends` 的限制条件：

  * 🌳 它的范围是所有直接和间接子类，还包括上界定义的父类本身，也就是 `水果`。

  * 🔗 它还有 `implements` 的意思，即这里的上界也可以是 `interface`。

🤨 这个突破限制有意义吗？

✅ 有的。

#### 🍎 假如我们有一个接口 `水果`：

```java
interface 水果 {
    float 获取重量();
}
```

#### 🍊 有两个水果类实现了 `水果` 接口：

```java
class 香蕉 implements 水果 {
    @Override
    public float 获取重量() {
        return 0.5f;
    }
}

class 苹果 implements 水果 {
    @Override
    public float 获取重量() {
        return 1f;
    }
}
```

#### 🍽️ 假设我们有个需求是需要给水果称重：

```java
List<苹果> 苹果列表 = new ArrayList<>();
苹果列表.add(new 苹果());
float 总重量 = 获取总重量(苹果列表);
// 👆 报错：Required type: List<水果> Provided: List<苹果>

private float 获取总重量(List<水果> 水果列表) {
    float 总重量 = 0;
    for (水果 水果 : 水果列表) {
        总重量 += 水果.获取重量();
    }
    return 总重量;
}
```

🤔 想来这也是一个非常正常的需求，秤可以称各种水果的重量，但也可以只称苹果。你不能因为我只买苹果就不给我称重吧。

#### 🍏 所以把上面的代码加上上界通配符就可以啦。

```java
List<苹果> 苹果列表 = new ArrayList<>();
苹果列表.add(new 苹果());
float 总重量 = 获取总重量(苹果列表);
// 👆 不再报错

// 👇 增加了上界通配符 ? extends
private float 获取总重量(List<? extends 水果> 水果列表) {
    float 总重量 = 0;
    for (水果 水果 : 水果列表) {
        总重量 += 水果.获取重量();
    }
    return 总重量;
}
```

🤔 然而，上面使用 `? extends` 上界通配符虽然突破了一层限制，却被施加了另一层限制：**只可输出不可输入**。

🧐 这是什么意思呢？

#### 🌰 比如：

```java
List<苹果> 苹果列表 = new ArrayList<苹果>();
List<? extends 水果> 水果列表 = 苹果列表;
水果 水果 = 水果列表.get(0);
水果列表.add(new 苹果());
// 👆 报错：Required type: capture of ? extends 水果 Provided: 苹果
```

🚫 声明了上界通配符泛型的集合，不再允许 `add` 新的对象，`苹果` 不行，`水果` 也不行。

#### 🔍 拓展开来说：不止是集合，自己编写一个泛型做输入也不行。

```java
interface 商店<T> {
    void 展示水果名称(T t);
    T 获取水果();
}

商店<? extends 水果> 苹果店 = new 商店<苹果>(){
    @Override
    public void 展示水果名称(苹果 苹果) { }

    @Override
    public 苹果 获取水果() {
        return null;
    }
};
苹果店.获取水果();
苹果店.展示水果名称(new 苹果());
// 👆 报错：Required type: capture of ? extends 水果 Provided: 苹果
```


### 🔽 泛型的下界通配符

🚧 与上界通配符 `? extends` 对应的就是下界通配符 `? super`

##### 🔄 下界通配符 `? super` 所有情况和 `? extends` 上界通配符刚刚相反：

* 🔍 通配符 `?` 表示 `List` 的泛型类型是一个未知类型。

* 📋 `super` 限制了这个未知类型的下界，也就是泛型类型必须满足这个 `super` 的限制条件

  * 🌳 它的范围不仅是所有直接和间接父类，还包括下界定义的子类本身。

  * 🔗 `super` 同样支持 `interface`。

* 🧐 与上界不同，父类有顶级限制，即 `Object`，所以实例化下界的泛型不是完全不能取值，而是所有返回这个泛型的方法只能取 `Object`

#### 🚫 它被施加的新限制是：只可输入不可输出。

```java
商店<? super 苹果> 苹果店 = new 商店<水果>(){
    @Override
    public void 展示水果名称(水果 苹果) { }

    @Override
    public 水果 获取水果() {
        return null;
    }
};
苹果店.展示水果名称(new 苹果());
苹果 苹果 = 苹果店.获取水果();
 // 👆 报错：Required type: 苹果 Provided: capture of ? super 苹果
```

🧐 让我解释一下，首先 `?` 表示未知类型，编译器无法确定它的具体类型。

🌟 虽然不知道它的具体类型，但在 Java 中任何对象都是 `Object` 的子类。

🔍 因此，这里只能将 `苹果店.获取水果()` 获取出来的对象赋值给 `Object`。

⚠️ 由于类型未知，直接赋值给一个 `苹果` 对象显然是不负责任的，我们需要进行一层强制转换，但强制转换本身可能会引发错误。

🍎 而 `苹果` 对象必定是这个未知类型的子类型，根据多态的特性，通过 `展示水果名称` 输入 `苹果` 对象在这里是合法的。

##### 🔄 简要总结一下，Java 的泛型本身不支持协变和逆变：

* 🔼 可以使用泛型通配符 `? extends` 来使泛型支持协变，但是「**只能读取不能修改**」，这里的修改仅指对泛型集合添加元素，如果是 `remove(int index)` 以及 `clear` 当然是可以的。

* 🔽 可以使用泛型通配符 `? super` 来使泛型支持逆变，但是「**只能修改不能读取**」，这里说的不能读取是指不能按照泛型类型读取，你如果按照 `Object` 读出来再强转当然也是可以的。

> 🚀 理解了 Java 的泛型之后，再理解 Kotlin 中的泛型，就比较容易了。