### 🔄 Java 中的泛型与通配符

### 泛型的上界通配符

因为 Java 的泛型本身具有「不可变性 Invariance」，所以即使 `Fruit` 类是 `Apple` 类的父类，但 Java 里面认为 `List<Fruit>` 和 `List<Apple>` 类型并不一致，也就是说，子类的泛型 `List<Apple>` 不属于泛型 `List<Fruit>` 的子类。

#### 所以这样的代码并不被运行:

```java
List<Apple> apples = new ArrayList<Apple>();
List<Fruit> fruits = apples;  
// 👆 多态用在这里会报错 Required type:List<Fruit> Provided: List<Apple>
```

🚫 那假如我们想突破这层限制，怎么办？

使用上界通配符 `? extends` ：

```java
List<Apple> apples = new ArrayList<Apple>();
List<? extends Fruit> fruits = apples;
// 👆使用上界通配符后，编译不再报错
```

「上界通配符」，可以使 Java 泛型具有「协变性 Covariance」，协变就是允许上面的赋值是合法的。

> 在继承关系树中，子类继承自父类，可以认为父类在上，子类在下。extends 限制了泛型类型的父类型，所以叫上界。
 
#### 它有两层意思：

- 其中 `?` 是个通配符，表示这个 `List` 的泛型类型是一个未知类型。

- `extends` 限制了这个未知类型的上界，也就是泛型类型必须满足这个 `extends` 的限制条件，这里和定义class 的 `extends` 关键字有点不一样：

  - 它的范围不仅是所有直接和间接子类，还包括上界定义的父类本身，也就是 `Fruit。`

  - 它还有 `implements` 的意思，即这里的上界也可以是 `interface。`

这个突破限制有意义么？

有的。

假如我们有一个接口 `Fruit`：

```java
interface Fruit {
    float getWeight();
}
```

有两个水果类实现了 `Fruit` 接口：

```java
class Banana implements Fruit {
    @Override
    public float getWeight() {
        return 0.5f;
    }
}

class Apple implements Fruit {
    @Override
    public float getWeight() {
        return 1f;
    }
}
```

假设我们有个需求是需要给水果称重：

```java
List<Apple> apples = new ArrayList<>();
apples.add(new Apple());
float totalWeight = getTotalWeight(apples); 
// 👆 报错：Required type: List<Fruit> Provided: List<Apple>

private float getTotalWeight(List<Fruit> fruitList) {
    float totalWeight = 0;
    for (Fruit fruit : fruitList) {
        totalWeight += fruit.getWeight();
    }
    return totalWeight;
}
```

想来这也是一个非常正常的需求，秤可以称各种水果的重量，但也可以只称苹果。你不能因为我只买苹果就不给我称重吧。

所以把上面的代码加上上界通配符就可以啦。

```java
List<Apple> apples = new ArrayList<>();
apples.add(new Apple());
float totalWeight = getTotalWeight(apples); 
// 👆 不再报错

// 👇 增加了上界通配符 ? extends
private float getTotalWeight(List<? extends Fruit> fruitList) {
    float totalWeight = 0;
    for (Fruit fruit : fruitList) {
        totalWeight += fruit.getWeight();
    }
    return totalWeight;
}
```

不过，上面使用 `? extends` 上界通配符突破了一层限制，却被施加了另一层限制：只可输出不可输入。

什么意思呢？

比如：

```java
List<Apple> apples = new ArrayList<Apple>();
List<? extends Fruit> fruits = apples;
Fruit fruit = fruits.get(0);
fruits.add(new Apple());
// 👆 报错：Required type: capture of ? extends Fruit Provided: Apple
```

声明了上界通配符泛型的集合，不再允许 `add` 新的对象，`Apple` `不行，Fruit` 也不行。拓展开来说：不止是集合，自己编写一个泛型做输入也不行。

```java
interface Shop<T> {
    void showFruitName(T t);
    T getFruit();
}

Shop<? extends Fruit> apples = new Shop<Apple>(){
    @Override
    public void showFruitName(Apple apple) { }

    @Override
    public Apple getFruit() {
        return null;
    }
};
apples.getFruit();
apples.showFruitName(new Apple());
// 👆 报错：Required type: capture of ? extends Fruit Provided: Apple
```


### 泛型的下界通配符

与上界通配符 `? extends` 对应的就是下界通配符 `? super`


#### 下界通配符 `? super` 所有情况和 `? extends` 上界通配符刚刚相反：

- 通配符 `?` 表示 `List` 的泛型类型是一个 未知类型。

- `super` 限制了这个未知类型的下界，也就是泛型类型必须满足这个 `super` 的限制条件

  - 它的范围不仅是所有直接和间接子父类，还包括下界定义的子类本身。

  - `super` 同样支持 `interface。`

#### 它被施加的新限制是：只可输入不可输出。

```java
Shop<? super Apple> apples = new Shop<Fruit>(){
    @Override
    public void showFruitName(Fruit apple) { }

    @Override
    public Fruit getFruit() {
        return null;
    }
};
apples.showFruitName(new Apple());
Apple apple = apples.getFruit();
 // 👆 报错：Required type: Apple Provided: capture of ? super Apple
```

解释下，首先 `?` 表示未知类型，编译器是不确定它的类型的。

虽然不知道它的具体类型，不过在 Java 里任何对象都是 `Object` 的子类，所以这里只能把 `apples.getFruit()` 获取出来的对象赋值给 `Object`。由于类型未知，所以直接赋值给一个 `Apple` 对象肯定是不负责任的，需要我们做一层强制转换，不过强制转换本身可能发生错误。

而 `Apple` 对象一定是这个未知类型的子类型，根据多态的特性，这里通过 `showFruitName` 输入 `Button` 对象是合法的。

#### 小结下，Java 的泛型本身是不支持协变和逆变的：

- 可以使用泛型通配符 `? extends` 来使泛型支持协变，但是「只能读取不能修改」，这里的修改仅指对泛型集合添加元素，如果是 `remove(int index)` 以及 `clear` 当然是可以的。

- 可以使用泛型通配符 `? super` 来使泛型支持逆变，但是「只能修改不能读取」，这里说的不能读取是指不能按照泛型类型读取，你如果按照 `Object` 读出来再强转当然也是可以的。

理解了 Java 的泛型之后，再理解 Kotlin 中的泛型，就比较容易了。