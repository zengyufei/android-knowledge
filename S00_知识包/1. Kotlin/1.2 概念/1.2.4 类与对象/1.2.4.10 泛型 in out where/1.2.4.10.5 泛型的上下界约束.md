## 🌟 泛型的上下界约束

上面讲的都是在使用的时候再对泛型进行限制，我们称之为「上界通配符」和「下界通配符」。那我们可以在函数设计的时候，就设置这个限制么？

可以的。

比如：

```kotlin
open class Animal
class PetShop<T : Animal?>(val t: T)
```

等同于 Java 的：

```java
class PetShop<T extends Animal> {
    private T t;

    PetShop(T t) {
        this.t = t;
    }
}
```

这样，我们在设计宠物店类 PetShop 就给支持的泛型设置了上界约束，支持的泛型类型必须是 Animal 的之类。所以我们使用的话：

```kotlin
class Cat : Animal()

val catShop = PetShop(Cat())
val appleShop = PetShop(Apple())
// 👆 报错：Type mismatch. Required: Animal? Found: Apple
```

很明显，Apple 并不是 Animal 的子类，当然不满足 PetShop 泛型类型的上界约束。

那....可以设置多个上界约束么？

当然可以，在 Java 中，给一个泛型参数声明多个约束的方式是，使用 &：

```java
class PetShop<T extends Animal & Serializable> {
                      // 👆 通过 & 实现了两个上界，必须是 Animal 和 Serializable 的子类或实现类
    private T t;

    PetShop(T t) {
        this.t = t;
    }
}
```

而在 Kotlin 中舍弃了 & 这种方式，而是增加了 where 关键字：

```kotlin
open class Animal
class PetShop<T>(val t: T) where  T : Animal?, T : Serializable
```

通过上面的方式，就实现了多个上界的约束。