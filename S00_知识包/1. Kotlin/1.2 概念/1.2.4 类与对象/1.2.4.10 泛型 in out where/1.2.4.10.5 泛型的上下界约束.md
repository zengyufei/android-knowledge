## 🌈 泛型的上下界约束

🔍 上面讲的都是在使用的时候再对泛型进行限制，我们称之为「`上界通配符`」和「`下界通配符`」。

🤔 那我们可以在函数设计的时候，就设置这个限制么？

✅ 可以的。

##### 🌰 比如：

```kotlin
// kotlin
open class 动物
class 宠物店<T : 动物?>(val 动物: T)
```

##### 🔄 等同于 Java 的：

```java
// Java
class 宠物店<T extends 动物> {
    private T 动物;

    宠物店(T 动物) {
        this.动物 = 动物;
    }
}
```

🏗️ 这样，我们在设计宠物店类 `宠物店` 就给支持的泛型设置了上界约束。

🐾 支持的泛型类型必须是 `动物` 的子类。

##### 🛍️ 所以我们使用的话：

```kotlin
// kotlin
class 猫 : 动物()

val 猫商店 = 宠物店(猫())
val 苹果商店 = 宠物店(苹果())
// 👆 报错：Type mismatch. Required: 动物? Found: 苹果
```

🍎 很明显，`苹果` 并不是 `动物` 的子类，当然不满足 `宠物店` 泛型类型的上界约束。
